import fs from 'fs-extra';
import path from 'node:path';
import type { ProjectContext } from '../core/context.js';

export async function writeSkills(context: ProjectContext, outputPath: string): Promise<void> {
  const skillsDir = path.join(outputPath, '.claude', 'skills');
  await fs.ensureDir(skillsDir);

  await Promise.all([
    fs.writeFile(path.join(skillsDir, 'flutter-patterns.md'), generateFlutterPatterns()),
    fs.writeFile(path.join(skillsDir, 'go-router-patterns.md'), generateGoRouterPatterns(context)),
    fs.writeFile(path.join(skillsDir, 'module-conventions.md'), generateModuleConventions()),
    fs.writeFile(path.join(skillsDir, 'prd.md'), generatePrdGuide()),
  ]);
}

function generateFlutterPatterns(): string {
  return [
    '# Flutter / Riverpod Patterns',
    '',
    '## Provider Naming Conventions',
    '',
    '- Providers are top-level `final` variables with a `Provider` suffix',
    '- Repository providers: `authRepositoryProvider`, `userRepositoryProvider`',
    '- State providers: `userNotifierProvider`, `authStateProvider`',
    '- Computed providers: `isLoggedInProvider`, `currentUserProvider`',
    '',
    '## Provider Types',
    '',
    '| Type | Use Case |',
    '|------|----------|',
    '| `Provider` | Computed values, repository instances, services |',
    '| `NotifierProvider` | Synchronous mutable state (Riverpod 2.0+) |',
    '| `AsyncNotifierProvider` | Async mutable state (Riverpod 2.0+) |',
    '| `FutureProvider` | One-shot async data (auto-disposes, caches) |',
    '| `StreamProvider` | Real-time streams (Firestore, WebSocket) |',
    '| `StateProvider` | Simple primitive state (bool, int, String) |',
    '',
    '## ref.watch vs ref.read',
    '',
    '- **`ref.watch()`**: Use inside `build()` methods and provider bodies. Re-builds when value changes.',
    '- **`ref.read()`**: Use inside callbacks, event handlers. Does NOT trigger rebuilds.',
    '- **`ref.listen()`**: Side effects in response to state changes (snackbars, navigation).',
    '',
    '## AsyncNotifier (preferred for Riverpod 2.0+)',
    '',
    '```dart',
    'final userProvider = AsyncNotifierProvider<UserNotifier, User?>(() {',
    '  return UserNotifier();',
    '});',
    '',
    'class UserNotifier extends AsyncNotifier<User?> {',
    '  @override',
    '  Future<User?> build() async {',
    '    return ref.watch(authRepositoryProvider).getCurrentUser();',
    '  }',
    '',
    '  Future<void> refresh() async {',
    '    state = const AsyncLoading();',
    '    state = await AsyncValue.guard(() =>',
    '      ref.read(authRepositoryProvider).getCurrentUser()',
    '    );',
    '  }',
    '}',
    '```',
    '',
    '## Provider Composition',
    '',
    '```dart',
    'final httpClientProvider = Provider<Dio>((ref) => Dio());',
    '',
    'final authDataSourceProvider = Provider<AuthRemoteDataSource>((ref) {',
    '  return AuthRemoteDataSourceImpl(ref.watch(httpClientProvider));',
    '});',
    '',
    'final authRepositoryProvider = Provider<AuthRepository>((ref) {',
    '  return AuthRepositoryImpl(ref.watch(authDataSourceProvider));',
    '});',
    '```',
    '',
    '## State Management Best Practices',
    '',
    '1. **Immutable state**: Use `freezed` for state classes to avoid mutation bugs',
    '2. **Single source of truth**: One provider owns each piece of state',
    '3. **Invalidation**: Use `ref.invalidate(provider)` to force a refresh',
    '4. **Family providers**: Use `.family` modifier for parameterized providers',
    '5. **Auto-dispose**: Use `.autoDispose` to clean up providers when not in use',
  ].join('\n');
}

function generateGoRouterPatterns(context: ProjectContext): string {
  const deepLinkingNote = context.modules.deepLinking
    ? [
        '',
        '## Deep Linking Integration',
        '',
        'This project has deep linking enabled. Routes are handled via `app_links`.',
      ].join('\n')
    : '';

  const authGuardNote = context.modules.auth
    ? [
        '',
        '## Auth Guards',
        '',
        '```dart',
        'GoRouter(',
        '  redirect: (context, state) {',
        '    final isLoggedIn = ref.read(isLoggedInProvider);',
        '    final isAuthRoute = state.matchedLocation.startsWith(\'/auth\');',
        '    if (!isLoggedIn && !isAuthRoute) return \'/auth/login\';',
        '    if (isLoggedIn && isAuthRoute) return \'/\';',
        '    return null;',
        '  },',
        ')',
        '```',
      ].join('\n')
    : '';

  return [
    '# go_router Patterns',
    '',
    '## Route Definition',
    '',
    'Routes are defined in `lib/core/router/app_router.dart` using TypedGoRoute for type-safe navigation.',
    '',
    '```dart',
    'part \'app_router.g.dart\';',
    '',
    '@TypedGoRoute<HomeRoute>(path: \'/\', routes: [',
    '  TypedGoRoute<ProfileRoute>(path: \'profile\'),',
    '])',
    '@immutable',
    'class HomeRoute extends GoRouteData {',
    '  const HomeRoute();',
    '',
    '  @override',
    '  Widget build(BuildContext context, GoRouterState state) => const HomePage();',
    '}',
    '```',
    '',
    '## Navigation',
    '',
    '```dart',
    '// Type-safe (preferred)',
    'const HomeRoute().go(context);',
    'ProfileRoute(userId: \'123\').push(context);',
    '```',
    authGuardNote,
    deepLinkingNote,
    '',
    '## Adding a New Route',
    '',
    '1. Create a route class with `@TypedGoRoute` annotation',
    '2. Implement the `build()` method returning the page widget',
    '3. Run `dart run build_runner build --delete-conflicting-outputs`',
    '4. Update the parent route\'s `routes` list if it\'s a child route',
  ].join('\n');
}

function generateModuleConventions(): string {
  return [
    '# Module Conventions (Clean Architecture)',
    '',
    '## Directory Structure Per Feature',
    '',
    '```',
    'lib/features/<feature-name>/',
    '├── domain/',
    '│   ├── entities/          # Pure Dart models (use freezed)',
    '│   ├── repositories/      # Abstract repository interfaces',
    '│   └── usecases/          # Single-responsibility business operations',
    '├── data/',
    '│   ├── datasources/       # Remote (API) and local (DB) data sources',
    '│   ├── models/            # Data transfer objects with serialization',
    '│   └── repositories/      # Repository implementations',
    '└── presentation/',
    '    ├── pages/             # Full-screen UI (route targets)',
    '    ├── widgets/           # Reusable UI components',
    '    └── providers/         # Riverpod providers and state notifiers',
    '```',
    '',
    '## Layer Dependency Rules',
    '',
    '```',
    'Domain ← Data ← Presentation',
    '```',
    '',
    '- **Domain**: No dependencies on other layers or external packages',
    '- **Data**: Depends on Domain only (implements repository interfaces)',
    '- **Presentation**: Depends on Domain only (accesses Data via providers)',
    '',
    '## Cross-Feature Communication',
    '',
    'Features should NOT import from each other directly. Use:',
    '',
    '- **Providers**: Share state through Riverpod providers in `lib/core/providers/`',
    '- **Entities**: Share domain entities through `lib/core/domain/`',
    '- **Events**: Use streams or callbacks for loose coupling',
    '',
    '## Adding a New Feature',
    '',
    '1. Create feature directory following the structure above',
    '2. Start with Domain layer: entities, repository interfaces, use cases',
    '3. Add Data layer: models, data sources, repository implementation',
    '4. Add Presentation layer: providers, pages, widgets',
    '5. Register routes in `lib/core/router/app_router.dart`',
    '6. Run code generation: `dart run build_runner build`',
    '7. Write tests in `test/features/<name>/`',
  ].join('\n');
}

function generatePrdGuide(): string {
  return [
    '# Working with prd.json',
    '',
    '## Story Structure',
    '',
    '```json',
    '{',
    '  "id": "S-001",',
    '  "phase": 1,',
    '  "priority": "P0",',
    '  "title": "Short imperative title",',
    '  "description": "Detailed description of what needs to be built",',
    '  "acceptanceCriteria": [',
    '    "Criterion 1 that must be true for the story to be complete",',
    '    "Criterion 2"',
    '  ],',
    '  "passes": false',
    '}',
    '```',
    '',
    '## Fields',
    '',
    '| Field | Type | Description |',
    '|-------|------|-------------|',
    '| `id` | string | Unique story identifier (e.g., "S-001") |',
    '| `phase` | number | Implementation phase (1=core, 2=features, 3=polish, 4=advanced) |',
    '| `priority` | string | P0 (critical), P1 (high), P2 (medium), P3 (low) |',
    '| `title` | string | Short description of what to implement |',
    '| `description` | string | Full requirements and context |',
    '| `acceptanceCriteria` | string[] | Measurable conditions that must be true when done |',
    '| `passes` | boolean | `true` when story is complete and quality gates pass |',
    '',
    '## Workflow for Implementing a Story',
    '',
    '1. **Read the story**: Understand the description and acceptance criteria',
    '2. **Plan**: Identify which files need to be created or modified',
    '3. **Implement**: Follow Clean Architecture layers (domain → data → presentation)',
    '4. **Test**: Write unit/integration tests covering the acceptance criteria',
    '5. **Quality gates**: Run `flutter analyze && flutter test`',
    '6. **Mark complete**: Set `"passes": true` in `prd.json`',
    '7. **Commit**: `git commit -m "feat: [S-001] - Story title"`',
    '',
    '## Marking a Story Complete',
    '',
    'Only mark `passes: true` when:',
    '- All acceptance criteria are demonstrably met',
    '- `flutter analyze` returns zero errors or warnings',
    '- `flutter test` passes all tests',
    '- Code follows Clean Architecture layer rules',
  ].join('\n');
}
