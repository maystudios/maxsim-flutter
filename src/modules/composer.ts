import type { ModuleManifest, ProviderContribution, RouteContribution } from '../types/module.js';
import type { ProjectContext } from '../core/context.js';

/**
 * Result of composing all active modules.
 * Contains merged dependencies, providers, routes, and env vars.
 */
export interface ComposeResult {
  /** Merged pubspec dependencies (name -> version constraint) */
  readonly dependencies: ReadonlyMap<string, string>;
  /** Merged pubspec dev dependencies (name -> version constraint) */
  readonly devDependencies: ReadonlyMap<string, string>;
  /** All provider contributions from active modules */
  readonly providers: readonly ProviderContribution[];
  /** All route contributions from active modules */
  readonly routes: readonly RouteContribution[];
  /** All environment variables needed by active modules */
  readonly envVars: readonly string[];
}

/**
 * Compares two semver-like version constraints and returns the "newer" one.
 * Strips leading ^ or ~ for comparison. If versions are identical, returns the first.
 */
export function pickNewerVersion(a: string, b: string): string {
  const stripPrefix = (v: string): string => v.replace(/^[\^~>=<!\s]+/, '');
  const partsA = stripPrefix(a).split('.').map(Number);
  const partsB = stripPrefix(b).split('.').map(Number);

  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
    const numA = partsA[i] ?? 0;
    const numB = partsB[i] ?? 0;
    if (numA > numB) return a;
    if (numB > numA) return b;
  }

  return a; // identical â€” keep first
}

/**
 * Composes resolved modules into a unified set of contributions.
 * Takes topologically sorted ModuleManifests and merges their
 * pubspec dependencies, provider contributions, route contributions,
 * and environment variables.
 */
export class ModuleComposer {
  /**
   * Compose contributions from an ordered list of modules.
   *
   * @param modules - Topologically sorted module manifests (from ModuleResolver)
   * @param context - Project context for evaluating isEnabled predicates
   * @returns Merged ComposeResult
   */
  compose(modules: readonly ModuleManifest[], context: ProjectContext): ComposeResult {
    const dependencies = new Map<string, string>();
    const devDependencies = new Map<string, string>();
    const providers: ProviderContribution[] = [];
    const routes: RouteContribution[] = [];
    const envVarsSet = new Set<string>();

    for (const mod of modules) {
      // Skip modules that have an isEnabled predicate that returns false
      if (mod.isEnabled && !mod.isEnabled(context)) {
        continue;
      }

      const contrib = mod.contributions;

      // Merge dependencies (newer version wins)
      if (contrib.pubspecDependencies) {
        for (const [name, version] of Object.entries(contrib.pubspecDependencies)) {
          const existing = dependencies.get(name);
          if (existing) {
            dependencies.set(name, pickNewerVersion(existing, version));
          } else {
            dependencies.set(name, version);
          }
        }
      }

      // Merge dev dependencies (newer version wins)
      if (contrib.pubspecDevDependencies) {
        for (const [name, version] of Object.entries(contrib.pubspecDevDependencies)) {
          const existing = devDependencies.get(name);
          if (existing) {
            devDependencies.set(name, pickNewerVersion(existing, version));
          } else {
            devDependencies.set(name, version);
          }
        }
      }

      // Collect providers
      if (contrib.providers) {
        providers.push(...contrib.providers);
      }

      // Collect routes
      if (contrib.routes) {
        routes.push(...contrib.routes);
      }

      // Collect environment variables
      if (contrib.envVars) {
        for (const envVar of contrib.envVars) {
          envVarsSet.add(envVar);
        }
      }
    }

    return {
      dependencies,
      devDependencies,
      providers,
      routes,
      envVars: [...envVarsSet],
    };
  }

  /**
   * Generate a pubspec.yaml dependencies block from a ComposeResult.
   * Returns a string with YAML-formatted dependency lines.
   */
  formatPubspecDependencies(deps: ReadonlyMap<string, string>): string {
    const sorted = [...deps.entries()].sort(([a], [b]) => a.localeCompare(b));
    return sorted.map(([name, version]) => `  ${name}: ${version}`).join('\n');
  }

  /**
   * Generate an app_providers.dart barrel file content from provider contributions.
   * Produces Dart export statements for each provider's import path.
   */
  generateAppProvidersBarrel(providers: readonly ProviderContribution[]): string {
    const lines = [
      '// Barrel file for shared application providers.',
      '// Auto-generated by maxsim-flutter. Do not edit manually.',
      "export '../router/app_router.dart';",
    ];

    // Deduplicate by importPath
    const seen = new Set<string>();
    seen.add('../router/app_router.dart');

    for (const provider of providers) {
      if (!seen.has(provider.importPath)) {
        seen.add(provider.importPath);
        lines.push(`export '${provider.importPath}';`);
      }
    }

    return lines.join('\n') + '\n';
  }
}
